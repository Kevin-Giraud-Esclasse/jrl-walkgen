// This is vxl/VNL/algo/amoeba.h
#ifndef vnl_amoeba_h_
#define vnl_amoeba_h_
#ifdef VCL_NEEDS_PRAGMA_INTERFACE
#pragma interface
#endif
/**
*  \file
*  \brief Nelder-Meade downhill simplex.

*  \author Andrew W. Fitzgibbon, Oxford RRG
*  \date   23 Oct 97
*
    \verbatim
    Modifications
    971023 AWF Initial version
    dac (Manchester) 26/03/2001: tidied up documentation
    Tim Cootes 7-Jan-02: Added documentation and additional methods
     Feb.2002 - Peter Vanroose - brief doxygen comment placed on single line
    \endverbatim
*/

//-----------------------------------------------------------------------------

#include <VNL/vector.h>

// Forward declare some useful things
namespace VNL {
  class CostFunction;
  class LeastSquaresFunction;

/** Nelder-Meade downhill simplex.
*  vnl_amoeba is an implementation of the Nelder-Meade downhill simplex
*  algorithm.  For most problems, it's a few times slower than
*  vnl_levenberg_marquardt, but it can perform much better on noisy error
*  functions.
*
*  It works by creating a simplex (n+1 points in n-D space) which then
*  crawls about the space searching for the solution.
*
*  By default the set of (n+1) starting points are generated by applying
*  a scaling (relative_diameter) to each element of the supplied starting
*  vector,  with a small offset used instead if the value is zero.
*
*  Alternatively, if one uses minimize(x,dx), then the starting points
*  are obtained by adding each dx[i] to the elements of x, one at a time.
*  This is useful if you know roughly the scale of your space.
*/

class Amoeba
{
 public:
  int verbose;
  int maxiter;
  double X_tolerance;
  double F_tolerance;

/** Define maximum number of iterations to use.
*/
  void SetMaxIterations(int n);

/** Define tolerance on elements of x.
*/
  void SetXTolerance(double tol);

/** Define tolerance on function evaluation.
*/
  void SetFTolerance(double tol);

/** Define scaling used to select starting vertices relative to intial x0.
*  I.e. the i'th vertex has x[i] = x0[i]*(1+relative_diameter)
*/
  void SetRelativeDiameter(double r);

/** Scaling used to select starting vertices relative to initial x0.
*  I.e. the i'th vertex has x[i] = x0[i]*(1+relative_diameter)
*/
  double relative_diameter;

/** Construct and supply function to be minimized.
*/
  Amoeba(VNL::CostFunction& f);

/** Modify x to minimise function supplied in constructor.
*  Start simplex defined by scaling elements of x
*/
  void Minimize(VNL::Vector<double>& x);

/** Perform optimisation.
*  Start simplex defined by adding dx[i] to each x[i]
*/
  void Minimize(VNL::Vector<double>& x, const VNL::Vector<double>& dx);

/** Number of evaluations used in last call to minimize.
*/
  int GetNumEvaluations() const { return num_evaluations_; }

 public:
/** Modify x so as to minimise f(x).
*/
  static void Minimize(VNL::CostFunction& f, VNL::Vector<double>& x);

/** Modify x so as to minimise f(x).
*  Start simplex defined by adding dx[i] to each x[i]
*/
  static void Minimize(VNL::CostFunction& f, VNL::Vector<double>& x,
                       const VNL::Vector<double>& dx);

/** Modify x so as to minimise f(x).
*  delta defines relative size of initial simplex
*  ie the i'th vertex has xi[i] = x[i]*(1+delta)
*/
  static void Minimize(CostFunction& f, Vector<double>& x,
                       double delta);

/** Modify x so as to minimise f(x).
*/
  static void Minimize(LeastSquaresFunction& f, Vector<double>& x);

  static bool default_verbose;

 protected:
  CostFunction* fptr;
  int num_evaluations_;
};

// Private struct needs to be declared in the header file
// in order to instantiate STL container of it elsewhere.
struct AmoebaSimplexCorner
{
  Vector<double> v;
  double fv;

  AmoebaSimplexCorner(int = 0);
  AmoebaSimplexCorner& operator= (const AmoebaSimplexCorner& that);
  static int Compare(AmoebaSimplexCorner const& s1,
                     AmoebaSimplexCorner const& s2);
};

}; // End namespace VNL

#endif // vnl_amoeba_h_
